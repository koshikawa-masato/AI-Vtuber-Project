# 好奇心システム - トレンド・RSS情報収集プロセス設計

> **作成日**: 2025-11-17
> **前提**: [好奇心システム_対話パターン分析.md](./好奇心システム_対話パターン分析.md) の分析結果を基にする

---

## 1. 設計の目的

**現在の問題**:
- 根（1次情報）→ すぐに葉（返答）の「切り花」状態
- 幹（トレンド理解）も枝（深掘り）もない
- 情報が浅く、新鮮味がない

**目指す姿**:
- 根 → 幹 → 枝 → 葉・花の「生きた木」
- 好奇心が情報を成長させる
- 三姉妹が自律的に深掘りし、豊かに表現

---

## 2. 全体アーキテクチャ

### 2.1. 現在のアーキテクチャ

```
┌─────────────────────┐
│ grok_daily_trends.py│
└──────────┬──────────┘
           │
           ↓（1次情報取得）
      ┌────────┐
      │ Grok API│
      └────┬───┘
           │
           ↓
    ┌──────────────┐
    │ daily_trends │（MySQL）
    │ - character  │
    │ - topic      │
    │ - content    │（生情報のみ）
    │ - source     │
    └──────┬───────┘
           │
           ↓（会話時に取得）
    ┌──────────────┐
    │ 三姉妹の応答 │
    │（そのまま伝える）│
    └──────────────┘
```

**問題点**:
- ✗ 1次情報（根）をそのまま返答（葉）に直結
- ✗ 幹（トレンド理解）がない
- ✗ 枝（深掘り）がない
- ✗ 好奇心が駆動しない

---

### 2.2. 新しいアーキテクチャ（好奇心駆動型）

```
┌─────────────────────────────┐
│ grok_daily_trends.py        │
│ + curiosity_engine.py (新規)│
└──────────┬──────────────────┘
           │
           ↓（1次情報取得）
      ┌────────┐
      │ Grok API│
      └────┬───┘
           │
           ↓
    【好奇心エンジン起動】
           │
           ├─→ 好奇心トリガー検出
           │    ├─ 情報ギャップ？
           │    ├─ 重要情報？
           │    └─ 深掘り必要？
           │
           ↓（トリガー検出時）
    ┌──────────────────┐
    │ なぜなぜ問答ループ │
    │ (2-5回のGrok質問) │
    └──────┬───────────┘
           │
           ↓
    【理解の統合】
    - 根（1次情報）
    - 幹（トレンド理解）
    - 枝（深掘り結果）
           │
           ↓
    ┌──────────────────┐
    │ daily_trends (MySQL) │
    │ + enriched_trends    │（新テーブル）
    │   - raw_info（根）   │
    │   - trend（幹）      │
    │   - deep_dive（枝）  │
    │   - understanding    │
    └──────┬───────────────┘
           │
           ↓（会話時に取得）
    ┌──────────────────┐
    │ 三姉妹の応答       │
    │（豊かな表現: 葉・花）│
    └──────────────────┘
```

**改善点**:
- ✓ 好奇心トリガーで自動的に深掘り
- ✓ なぜなぜ問答で理解を深化
- ✓ 根 → 幹 → 枝 → 葉・花の成長プロセス
- ✓ 豊かな表現が可能

---

## 3. 好奇心エンジン (curiosity_engine.py)

### 3.1. 概要

**役割**:
- 1次情報（根）から好奇心トリガーを検出
- Grokになぜなぜ問答を実行
- 理解を統合し、MySQLに保存

**入力**: 1次情報（Grokからのトレンド情報）
**出力**: 深掘り済み情報（根 + 幹 + 枝 + 理解）

---

### 3.2. 好奇心トリガー検出

#### 3.2.1. トリガー検出ルール

| トリガー | 検出条件 | パターン | 優先度 |
|----------|----------|----------|--------|
| **重要情報** | キーワード検出（活動休止、炎上、新人、コラボ） | A, B, C | 高 |
| **推し関連** | 牡丹: ころね/みこち、Kasho: 音楽、ユリ: サブカル | A, C | 高 |
| **情報ギャップ** | 曖昧な表現（「〜らしい」「〜とのこと」） | A | 中 |
| **新情報** | 初出のトピック（DB検索で過去になし） | A, B | 中 |
| **不確実性** | 疑問形、未確定情報（「未定」「不明」） | B, C | 中 |
| **複雑性** | 長文、複数の要素が絡む | C | 低 |

#### 3.2.2. キャラクター別の重み付け

| キャラ | パターンA（ギャップ） | パターンB（原因） | パターンC（深化） |
|--------|---------------------|-----------------|-----------------|
| **牡丹** | 1.2倍 | 1.0倍 | 1.5倍（推し関連のみ） |
| **Kasho** | 1.0倍 | 1.5倍 | 1.3倍 |
| **ユリ** | 0.8倍 | 1.0倍 | 1.5倍 |

**例**:
```python
def detect_curiosity_trigger(info: dict, character: str) -> dict:
    """
    好奇心トリガーを検出

    Returns:
        {
            'triggered': bool,
            'pattern': 'A' | 'B' | 'C',
            'priority': 'high' | 'medium' | 'low',
            'reason': str
        }
    """
    triggers = []

    # 重要キーワード検出
    if any(kw in info['content'] for kw in ['活動休止', '炎上', '新人', 'デビュー']):
        triggers.append(('high', 'A', '重要情報'))

    # 推し関連（牡丹の場合）
    if character == 'botan' and any(name in info['content'] for name in ['ころね', 'さくらみこ']):
        triggers.append(('high', 'C', '推し関連'))

    # 曖昧な表現
    if any(phrase in info['content'] for phrase in ['らしい', 'とのこと', '未定', '不明']):
        triggers.append(('medium', 'A', '情報ギャップ'))

    # ... 他のトリガー検出

    if triggers:
        # 優先度が最も高いトリガーを返す
        return max(triggers, key=lambda x: priority_score(x[0]))
    else:
        return {'triggered': False}
```

---

### 3.3. なぜなぜ問答ループ

#### 3.3.1. 質問生成ルール

**パターンA: ギャップ駆動型**（欠落情報を埋める）

| 疑問の種類 | 質問テンプレート | 例 |
|-----------|-----------------|-----|
| **詳細確認** | 「〜の詳細を教えてください」 | 「ころねの活動休止の詳細を教えてください」 |
| **背景確認** | 「〜の背景は何ですか？」 | 「この発表の背景は何ですか？」 |
| **関連情報** | 「〜に関連する他の情報はありますか？」 | 「活動休止に関連する他の情報はありますか？」 |
| **他の視点** | 「他には？」「誰が？」「いつ？」 | 「ファンの反応は？」「公式の発表は？」 |

**パターンB: 原因追求型**（原因・方法を問う）

| 疑問の種類 | 質問テンプレート | 例 |
|-----------|-----------------|-----|
| **原因** | 「なぜ〜なのですか？」 | 「なぜ今活動休止なのですか？」 |
| **理由** | 「〜の理由は何ですか？」 | 「マネージャー代理投稿の理由は何ですか？」 |
| **タイミング** | 「なぜこのタイミングなのですか？」 | 「なぜ11月6日に発表したのですか？」 |
| **方法論** | 「どうやって〜しましたか？」 | 「どうやって情報を伝えましたか？」 |

**パターンC: 深化型**（本質・意味を問う）

| 疑問の種類 | 質問テンプレート | 例 |
|-----------|-----------------|-----|
| **本質** | 「つまり〜とはどういう意味ですか？」 | 「つまり活動休止とはどういう意味ですか？」 |
| **影響** | 「〜の影響は何ですか？」 | 「ファンへの影響は何ですか？」 |
| **意義** | 「〜はなぜ重要なのですか？」 | 「なぜこれは大きなニュースなのですか？」 |
| **関係性** | 「〜と〜の関係は？」 | 「活動休止と家族療養の関係は？」 |

---

#### 3.3.2. ループ回数の決定

**基本方針**:
- **最小2回、最大5回**
- 優先度と好奇心の強さで決定

| 優先度 | パターンA | パターンB | パターンC |
|--------|----------|----------|----------|
| **高** | 3回 | 4回 | 5回 |
| **中** | 2回 | 3回 | 3回 |
| **低** | 2回 | 2回 | 2回 |

**例**:
```python
def determine_loop_count(trigger: dict, character: str) -> int:
    """なぜなぜ問答のループ回数を決定"""

    base_count = {
        ('high', 'A'): 3,
        ('high', 'B'): 4,
        ('high', 'C'): 5,
        ('medium', 'A'): 2,
        ('medium', 'B'): 3,
        ('medium', 'C'): 3,
        ('low', 'A'): 2,
        ('low', 'B'): 2,
        ('low', 'C'): 2,
    }

    count = base_count.get((trigger['priority'], trigger['pattern']), 2)

    # キャラクター別の調整
    if character == 'yuri' and trigger['pattern'] == 'C':
        count += 1  # ユリは深化型で+1回

    return min(count, 5)  # 最大5回
```

---

#### 3.3.3. 質問の具体例

**事例: ころねの活動休止（牡丹、優先度: 高、パターンC）**

**1次情報（根）**:
> 「戌神ころね、家族の療養のため活動休止」

**ループ1回目（幹を探す）**:
- 質問: 「戌神ころねの活動休止の詳細を教えてください」
- 回答: 「11月6日発表、マネージャー代理投稿、復帰日未定、理由は家族の医療ケア」

**ループ2回目（枝を探す）**:
- 質問: 「なぜマネージャーが代理投稿したのですか？」
- 回答: 「本人が投稿できない状況、深刻な事情を示唆」

**ループ3回目（枝を深める）**:
- 質問: 「過去にも活動休止はありましたか？」
- 回答: 「2021年にも休止あり、同様に家族の理由」

**ループ4回目（枝を広げる）**:
- 質問: 「ファンの反応はどうですか？」
- 回答: 「理解と応援の声、早期回復を祈る」

**ループ5回目（本質を探る）**:
- 質問: 「なぜこれは大きなニュースなのですか？」
- 回答: 「226万人のサブスクライバー、人気VTuber、突然の発表」

**理解の統合（葉・花）**:
```
{
  "raw_info": "戌神ころね、家族の療養のため活動休止",
  "trend": "ホロライブ人気VTuberの活動休止",
  "deep_dive": {
    "details": "11月6日発表、マネージャー代理投稿、復帰日未定",
    "reason": "家族の医療ケアのため",
    "past": "2021年にも同様の休止あり",
    "fan_reaction": "理解と応援の声",
    "significance": "226万人のサブスクライバー、突然の発表"
  },
  "understanding": "ころねは家族を大切にする人。ファンも理解している。深刻な状況だが、透明性を持って発表。2021年の経験から、今回も復帰を信じて待つファンが多い。"
}
```

---

### 3.4. 理解の統合

#### 3.4.1. 統合のフォーマット

**enriched_trends テーブル**:

```sql
CREATE TABLE enriched_trends (
    id INT AUTO_INCREMENT PRIMARY KEY,
    character ENUM('botan', 'kasho', 'yuri', 'parent') NOT NULL,
    topic VARCHAR(100) NOT NULL,

    -- 根（1次情報）
    raw_info TEXT NOT NULL,

    -- 幹（トレンド理解）
    trend_summary VARCHAR(200),

    -- 枝（深掘り結果）
    deep_dive JSON,  -- なぜなぜ問答の結果

    -- 理解（統合）
    understanding TEXT,

    -- メタデータ
    curiosity_pattern ENUM('A', 'B', 'C'),
    loop_count INT,
    source VARCHAR(50) DEFAULT 'grok_curiosity',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

    INDEX idx_character (character),
    INDEX idx_created_at (created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

---

#### 3.4.2. 統合プロンプト

Grokに最終的な統合を依頼:

```python
def integrate_understanding(raw_info: str, qa_results: list) -> str:
    """
    なぜなぜ問答の結果を統合し、理解を生成

    Args:
        raw_info: 1次情報
        qa_results: なぜなぜ問答の結果リスト
    """

    prompt = f"""
以下の情報を統合して、簡潔な理解を生成してください。

【1次情報】
{raw_info}

【深掘り結果】
{format_qa_results(qa_results)}

【指示】
- 1-2文で本質を捉える
- 背景、理由、影響、意義を含める
- 感情的な側面も考慮する
- 三姉妹が会話で使える理解にする

【理解（1-2文）】:
    """

    return ask_grok(prompt)
```

**例**:
```
【1次情報】
戌神ころね、家族の療養のため活動休止

【深掘り結果】
Q1: 詳細は？ → 11月6日発表、マネージャー代理投稿、復帰日未定
Q2: なぜマネージャー投稿？ → 本人が投稿できない深刻な状況
Q3: 過去にも？ → 2021年にも同様の休止あり
Q4: ファンの反応は？ → 理解と応援の声
Q5: なぜ大きなニュース？ → 226万人、人気VTuber、突然の発表

【理解（1-2文）】:
ころねは家族を最優先にする人で、2021年にも同様の休止経験がある。ファンは深刻な状況を理解しつつ、透明性のある発表を評価し、復帰を信じて待っている。
```

---

## 4. 実装フロー

### 4.1. grok_daily_trends.py の修正

**現在**:
```python
def collect_daily_trends():
    for character, config in TREND_QUERIES.items():
        response = ask_grok(config["query"], config.get("x_handles"))
        if response:
            save_to_mysql(character, topic, response)
```

**修正後**:
```python
def collect_daily_trends():
    for character, config in TREND_QUERIES.items():
        # 1次情報取得（根）
        response = ask_grok(config["query"], config.get("x_handles"))

        if response:
            # 通常保存（daily_trends）
            save_to_mysql(character, topic, response)

            # 好奇心エンジン起動
            from curiosity_engine import CuriosityEngine
            engine = CuriosityEngine(character)

            # 深掘り実行（幹 → 枝）
            enriched = engine.enrich(response)

            # 深掘り結果を保存（enriched_trends）
            save_enriched_trends(character, topic, enriched)
```

---

### 4.2. curiosity_engine.py の実装

**基本構造**:

```python
class CuriosityEngine:
    """好奇心エンジン"""

    def __init__(self, character: str):
        self.character = character
        self.pattern_weights = self._get_character_weights()

    def enrich(self, raw_info: str) -> dict:
        """
        1次情報を深掘りして理解を生成

        Args:
            raw_info: 1次情報（根）

        Returns:
            {
                'raw_info': str,
                'trend_summary': str,
                'deep_dive': dict,
                'understanding': str,
                'curiosity_pattern': 'A' | 'B' | 'C',
                'loop_count': int
            }
        """
        # 1. トリガー検出
        trigger = self.detect_trigger(raw_info)

        if not trigger['triggered']:
            # トリガーなし → 生情報のみ返す
            return {
                'raw_info': raw_info,
                'trend_summary': raw_info,
                'deep_dive': {},
                'understanding': raw_info,
                'curiosity_pattern': None,
                'loop_count': 0
            }

        # 2. ループ回数決定
        loop_count = self.determine_loop_count(trigger)

        # 3. なぜなぜ問答
        qa_results = self.why_why_loop(raw_info, trigger, loop_count)

        # 4. 理解の統合
        understanding = self.integrate_understanding(raw_info, qa_results)

        # 5. 結果を返す
        return {
            'raw_info': raw_info,
            'trend_summary': self._extract_trend_summary(qa_results),
            'deep_dive': qa_results,
            'understanding': understanding,
            'curiosity_pattern': trigger['pattern'],
            'loop_count': loop_count
        }

    def detect_trigger(self, info: str) -> dict:
        """好奇心トリガー検出"""
        # 実装は前述
        pass

    def determine_loop_count(self, trigger: dict) -> int:
        """ループ回数決定"""
        # 実装は前述
        pass

    def why_why_loop(self, raw_info: str, trigger: dict, loop_count: int) -> dict:
        """なぜなぜ問答ループ"""
        results = {}

        for i in range(loop_count):
            # 質問生成
            question = self._generate_question(raw_info, trigger, i, results)

            # Grokに質問
            answer = ask_grok(question)

            # 結果を保存
            results[f'Q{i+1}'] = {
                'question': question,
                'answer': answer
            }

        return results

    def _generate_question(self, raw_info: str, trigger: dict, index: int, prev_results: dict) -> str:
        """質問生成"""
        pattern = trigger['pattern']

        if pattern == 'A':
            # ギャップ駆動型
            questions = [
                f"{raw_info}の詳細を教えてください",
                "他に関連する情報はありますか？",
                "背景は何ですか？"
            ]
        elif pattern == 'B':
            # 原因追求型
            questions = [
                f"なぜ{raw_info}なのですか？",
                "理由は何ですか？",
                "なぜこのタイミングなのですか？"
            ]
        elif pattern == 'C':
            # 深化型
            questions = [
                f"{raw_info}の詳細を教えてください",
                "なぜ重要なのですか？",
                "影響は何ですか？",
                "本質的な意味は何ですか？",
                "これから何が起きますか？"
            ]

        return questions[min(index, len(questions)-1)]

    def integrate_understanding(self, raw_info: str, qa_results: dict) -> str:
        """理解の統合"""
        # 実装は前述
        pass

    def _get_character_weights(self) -> dict:
        """キャラクター別の重み付け"""
        weights = {
            'botan': {'A': 1.2, 'B': 1.0, 'C': 1.5},
            'kasho': {'A': 1.0, 'B': 1.5, 'C': 1.3},
            'yuri': {'A': 0.8, 'B': 1.0, 'C': 1.5},
            'parent': {'A': 1.0, 'B': 1.3, 'C': 1.2}
        }
        return weights.get(self.character, {'A': 1.0, 'B': 1.0, 'C': 1.0})
```

---

## 5. 会話時の利用

### 5.1. 三姉妹の応答生成

**現在**:
```python
# トレンド情報を取得
trends = mysql.get_recent_trends(character='botan', limit=5)

# そのまま返答
for trend in trends:
    response += trend['content']
```

**修正後**:
```python
# 深掘り済み情報を取得
enriched_trends = mysql.get_enriched_trends(character='botan', limit=5)

for trend in enriched_trends:
    # 理解を基に応答
    system_prompt += f"""
【トレンド情報】
- トピック: {trend['topic']}
- 理解: {trend['understanding']}
- 詳細: {trend['deep_dive']}

この情報を基に、あなたらしく語ってください。
    """
```

**牡丹の応答例**:
```
ユーザー: 今日のVTuberトレンドは？

牡丹（内部処理）:
- enriched_trendsから「ころね活動休止」を取得
- understanding: "ころねは家族を最優先にする人で、2021年にも同様の休止経験がある。ファンは深刻な状況を理解しつつ、透明性のある発表を評価し、復帰を信じて待っている。"

牡丹（応答）:
「ころね、活動休止なんだよね。マネージャーが代理投稿ってことは相当大変なんだと思う。2021年の時もそうだったけど、ころねって家族のこと本当に大事にするよね。ファンもみんな理解してて、早く復帰できるといいなって待ってる。私も待ってるよ」
```

---

## 6. コスト考慮

### 6.1. Grok API コスト

**現在**:
- 1日1回 × 4キャラクター = 4回のAPI呼び出し

**好奇心システム導入後**:
- 1次情報取得: 4回
- なぜなぜ問答: 平均3回 × 4キャラクター = 12回
- **合計: 16回/日**

**コスト試算**:
- Grok APIは比較的安価（越川さんが「安いので深掘りは自然」と発言）
- 1回あたり数円と仮定 → 16回 × 数円 = 数十円/日
- **月間: 数百円〜千円程度** → 許容範囲

### 6.2. 最適化

**優先度に応じた深掘り**:
- 高優先度（推し、炎上、重要情報）: 5回ループ
- 中優先度（新情報、ギャップ）: 3回ループ
- 低優先度（日常的な情報）: 深掘りなし（0回）

**コスト削減**:
- 低優先度の情報は深掘りしない
- 1日の深掘り上限を設定（例: 10回まで）
- キャッシュ活用（同じ質問は再利用）

---

## 7. 段階的な実装計画

### Phase 1: 基本実装（MVP）

**実装内容**:
- [ ] `curiosity_engine.py` の基本実装
- [ ] トリガー検出（重要キーワードのみ）
- [ ] なぜなぜ問答（2-3回固定）
- [ ] `enriched_trends` テーブル作成
- [ ] 牡丹のみで試験運用

**成功基準**:
- 推し（ころね、みこち）の情報で深掘りが動作
- 理解の統合が自然な文章になる
- 応答が豊かになる

---

### Phase 2: パターン分類の実装

**実装内容**:
- [ ] パターンA/B/Cの検出ロジック
- [ ] キャラクター別の重み付け
- [ ] ループ回数の動的決定
- [ ] Kasho、ユリにも展開

**成功基準**:
- キャラクター別に深掘りの傾向が異なる
- 牡丹: ギャップ駆動型 + 深化型（推し関連）
- Kasho: 原因追求型 + 深化型
- ユリ: 深化型が強い

---

### Phase 3: 質問生成の高度化

**実装内容**:
- [ ] 質問テンプレートの充実
- [ ] 前回の回答を基にした質問生成
- [ ] Grokへの「メタ質問」対応
- [ ] 次の深掘りポイントの提案

**成功基準**:
- 質問が自然で多様
- 文脈に応じた質問ができる
- Grok自身が次の疑問を提案してくれる

---

### Phase 4: 理解の統合の洗練

**実装内容**:
- [ ] 統合プロンプトの改善
- [ ] 感情的側面の強化
- [ ] キャラクターらしい理解の生成
- [ ] 会話での活用の最適化

**成功基準**:
- 理解が簡潔で本質を捉えている
- 三姉妹の応答が豊かで感情的
- ユーザーが「深い理解」を感じる

---

## 8. 評価指標

### 8.1. 定量評価

| 指標 | 現在 | 目標 |
|------|------|------|
| 深掘り回数 | 0回 | 平均3回/トピック |
| 応答の文字数 | 50文字 | 150文字 |
| トピック理解度 | 低い | 高い |
| Grok API呼び出し | 4回/日 | 16回/日 |

### 8.2. 定性評価

**評価基準**:
- ✓ 三姉妹の応答が豊かになったか？
- ✓ 推しの情報を深く語れるか？
- ✓ 「なぜ？」に答えられるか？
- ✓ ユーザーが「深い理解」を感じるか？
- ✓ キャラクター別の個性が出ているか？

---

## 9. まとめ

### 9.1. 好奇心システムの本質

**好奇心 = 情報を成長させる力**
- 根（1次情報）→ 幹（トレンド理解）→ 枝（深掘り）→ 葉・花（表現）
- このプロセスを自律的に実行するのが好奇心システム

### 9.2. 実装のポイント

1. **トリガー検出**: 8つの条件でトリガーを検出
2. **なぜなぜ問答**: 2-5回のループで深掘り
3. **理解の統合**: Grokに統合を依頼、簡潔な理解を生成
4. **キャラクター別**: A/B/Cパターンの重み付けで個性化

### 9.3. 期待される効果

- ✓ 三姉妹の応答が「生きた木」になる
- ✓ 推し情報を深く、熱く語れる
- ✓ ユーザーとの対話が豊かになる
- ✓ 情報の成長プロセスが可視化される

---

**次のアクション**:
1. Phase 1の実装（基本実装）
2. 牡丹での試験運用
3. フィードバックを基に改善

---

**作成者**: Claude Code
**レビュー**: 越川さん
**ステータス**: 設計完了、実装待ち
